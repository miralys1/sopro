	Das dynamische Verhalten des Systems wird mittels Sequenzdiagrammen modelliert.
	Hier wird zunächst ein grobes geräteübergreifendes Diagramm vorgestellt.
	Die restlichen Sequenzdiagramme beziehen sich nur auf wichtige Methoden in den gekapselten Ökosystemen APP, Website und Backend. Deswegen werden Lost und Found Messages verwendet, um die Kommunikation mit dem Server darzustellen. 
	

\subsection*{Sequenzdiagramm: Öffnen der ListActivity}

\begin{figure}[h]
	\centering
%\includegraphics[width= \linewidth ]{img/SDListAct.svg}
	\missingfigure{Sequenzdiagramm}			
	\caption{Sequenzdiagramm - Öffnen der ListActivity}
	\label{fig:sequenz-a}
\end{figure}
\noindent
Dieses Sequenzdiagramm zeigt den Vorgang, der abläuft, wenn die ListActivity initial gestartet wird und mit einer Liste aus Kompositionseinträgen zu füllen ist.
Da der Nutzer noch nicht eingeloggt ist, wird eine requestList()-Anfrage ohne Token gestartet. Diese wird in einem eigenen Thread ausgeführt, damit der UI-Thread nicht blockiert. Die Methode requestList() führt einen HTTPS-Request an das Backend aus. In der Zeit, in der die ListActivity die Antwort noch nicht erhalten hat, zeigt sie mithilfe von showLoading() eine Ladeanimation an.

\section*{Sequenzdiagramme der App}
\subsection*{Sequenzdiagramm: Klicken auf Kompositionseintrag}

\begin{figure}[h]
	\centering
	%\includegraphics[width= \linewidth ]{img/SDDetail.svg}
	\missingfigure{Sequenzdiagramm}		
	\caption{Sequenzdiagramm - Klick auf Kompositionseintrag}
	\label{fig:sequenz-a}
\end{figure}

Dieses Sequenzdiagramm beginnt damit, dass der Nutzer auf ein Listenelement tippt, um die Detailansicht aufzurufen. 
Dadruch wird die Methode startDetailActivity() aufgerufen, die die Klasse ServerCommunication veranlasst, im LokalCache nach der gewünschten Komposition zu suchen.
Falls diese noch nicht im Cache ist, wird ein HTTPS-Request an den Server gesendet.
In der Antwort sind dann alle nötigen Details der Komposition enthalten.
Diese werden dann im LokalCache abgelegt und an die ListActivity zurückgegeben.
Damit wird dann ein Intent erstellt und die DetailActivity gestartet.
\\
Da LocalCache ein Singleton ist, muss zu Beginn die Instanz abgerufen werden. Wir planen die Instanz vorzudefinieren (eager instantiation), wodurch der Fall, dass die Instanz erst erzeugt werden muss, nie eintritt.
\\
Die Methode httpsRequest() wird nicht implementiert, sondern dient hier zur Abstraktion. In der Implementation wird diese Abfrage asynchron ablaufen und in einem anderen Thread laufen, so dass der UI-Thread nicht blockiert wird. 

\section*{Sequenzdiagramme des Models}

\begin{figure}[h]
	\centering
	%\includegraphics[width= \linewidth ]{img/SDDetail.svg}
	\missingfigure{Sequenzdiagramm}		
	\caption{Sequenzdiagramm - Kompositionsanfrage}
	\label{fig:sequenz-a}
\end{figure}
\noindent
Das Sequenzdiagramm zeigt, wie eine Komposition in Detailansicht angefragt wird. 
Eine solche Anfrage wird vom CompositionsController entgegengenommen.
Die angefragte Komposition wird in der Datenbank nachgeschlagen (über das CompositionRepository) und als Composition-Objekt zurückgegeben.
Anschließend wird eine DetailComp erstellt, welche die benötigten Daten für das Frontend enthält. 
Um diese zu erstellen, müssen zunächst alle CompositionNodes und danach alle CompositionEdges in versendbare Objekte (Nodes und Edges) umgewandelt werden. 
Dabei wird für jede Kante noch die Kompatibilität überprüft und mögliche Alternativen werden gesucht und ggf. gespeichert. Zurückgeliefert wird also eine DetailComp, die in allen Kanten eine CompatibilityAnswer enthält.\newline
\\ \noindent
Wir haben uns dafür entschieden, eine Util-Klasse zur Berechnung der Compatibility zwischen zwei verschiedenen Diensten (repräsentiert durch ihre IDs) zu benutzen.
Da auch HTTPS-Requests erwartet werden, die nur zu zwei einzelnen Diensten die Kompatibilität erfahren wollen, wäre eine Implementierung dieser Funktion in der Edge-Klasse unpraktisch.\newline
\\ \noindent
Da dieses Sequenzdiagramm das komplexeste ist und sich viele andere Abläufe in ihm widerspiegeln, ist hier nur dieses als Repräsentant der Arbeitsweise unseres Backends aufgeführt.

